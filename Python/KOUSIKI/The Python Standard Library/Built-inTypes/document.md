以下は、ご提供いただいた「Built‑in Types」などのセクションを含むドキュメント全文の日本語訳です。  
（※以下の訳文は公式ドキュメントの各項目の内容をできるだけ忠実に反映したものです。）

---

# 組み込み型

このセクションでは、インタプリタに組み込まれている標準的な型について説明します。  
主要な組み込み型には、数値、シーケンス、マッピング、クラス、インスタンス、例外などがあります。

なお、いくつかのコレクションクラスは可変であり、要素の追加・削除・順序変更を行うメソッド（返り値として自身ではなく常に None を返すもの）が用意されています。  
また、ほとんどのオブジェクトは等価性の比較、真偽値の判定、文字列変換（repr() や str() など）が可能です。  
（str() は print() によって暗黙的に利用されます。）

---

## 真偽値の判定

任意のオブジェクトは、if や while の条件、あるいは以下のブール演算子の被演算子として真偽値が判定できます。  
基本的に、オブジェクトのクラスが **bool**() を定義していて False を返すか、あるいは **len**() が 0 を返す場合を除いて、すべて真とみなされます。[1]  
以下は、組み込みで偽と評価される主なオブジェクトです。

- 偽に定義された定数： None と False
- 数値型のゼロ： 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
- 空のシーケンスおよびコレクション： ''、()、[]、{}、set()、range(0)

また、ブール結果を返す演算子や組み込み関数は、偽の場合は 0 または False、真の場合は 1 または True を返します。ただし、特筆すべき例外として、or および and は常にそのオペランドのいずれかを返します。

---

## ブール演算子 — and, or, not

以下は、ブール演算子の優先順位が昇順に並んだものです。

| 演算子      | 結果                                  | 備考  |
| ----------- | ------------------------------------- | ----- |
| **x or y**  | x が真なら x、そうでなければ y        | （1） |
| **x and y** | x が偽なら x、そうでなければ y        | （2） |
| **not x**   | x が偽なら True、そうでなければ False | （3） |

※なお、and と or は短絡評価を行います。また、not の優先順位は非ブール演算子より低いため、例えば  
`not a == b` は `not (a == b)` と解釈され、`a == not b` は構文エラーとなります。

---

## 比較演算

Python には 8 種類の比較演算子があり、すべて同じ優先順位（ブール演算子より高い）を持ちます。  
比較は連鎖可能で、例えば  
`x < y <= z`  
は `x < y and y <= z` と同等ですが、y は一度だけ評価されます。（x < y が偽なら z は評価されません。）

比較演算の対応表は以下の通りです。

| 演算子   | 意味                     |
| -------- | ------------------------ |
| `<`      | 厳密な小なり             |
| `<=`     | 以下                     |
| `>`      | 厳密な大なり             |
| `>=`     | 以上                     |
| `==`     | 等しい                   |
| `!=`     | 等しくない               |
| `is`     | オブジェクト同一性       |
| `is not` | 否定のオブジェクト同一性 |

異なる型のオブジェクト（ただし、数値型同士の異なる型は例外）は決して等しくは比較されません。  
また、== は常に定義されていますが、（例えばクラスオブジェクトの場合） is と同等になることがあります。  
<, <=, >, >= は意味が通じる場合にのみ定義され、複素数の場合は TypeError が発生します。  
クラスのインスタンス同士は、通常 **eq**() を定義しない限り非等価と比較されます。また、順序付けは **lt**(), **le**(), **gt**(), **ge**() が定義されている場合のみ可能です。  
なお、is および is not の挙動はカスタマイズできず、どんな 2 つのオブジェクトにも適用可能です。  
さらに、in および not in という演算子も、イテラブルな型や **contains**() を実装している型でサポートされています。

---

## 数値型 — int, float, complex

Python には 3 つの主要な数値型があります：整数、浮動小数点数、複素数です。  
さらに、ブール値は整数のサブタイプとなっています。

- **整数 (int)** は任意の精度を持ちます。
- **浮動小数点数 (float)** は C の double を利用して実装されるのが通常で、精度や内部表現の詳細は sys.float_info で確認できます。
- **複素数 (complex)** は実部と虚部（それぞれ float 型）から構成され、z.real および z.imag でアクセスできます。  
  また、標準ライブラリには分数を扱う fractions.Fraction や、ユーザー定義精度の小数を扱う decimal.Decimal などの追加数値型も含まれています。

数値は数値リテラルまたは組み込み関数や演算子の結果として生成されます。  
整数リテラル（10 進、16 進、8 進、2 進など）は int を生成し、  
小数点や指数部を含むリテラルは float を生成します。  
末尾に 'j' または 'J' を付けると、虚部のみが非ゼロの複素数が生成され、整数や float と加算すると複素数となります。

Python は混合型の算術演算を完全にサポートしています。  
二項演算子で異なる数値型がある場合、より狭い型（整数 < 浮動小数点数 < 複素数）が広い型に変換され、正確な値同士が比較されます。[2]

また、int(), float(), complex() などのコンストラクタを使って、明示的に数値型の変換が可能です。

### 数値演算の主な演算子とその効果

（※詳細な表は省略しますが、加算、減算、乗算、除算、床除算、剰余、べき乗、符号反転、絶対値、整数変換、浮動小数点変換、複素数生成、複素共役、divmod などがサポートされます。）

※特記事項として、

- 整数の床除算は常にマイナス無限大方向に丸められ、
- 浮動小数点から整数への変換は小数部を切り捨て、
- 0\*\*0 は 1 と定義される、などの挙動があります。

また、Real 型（int と float）には math.trunc(), round(), math.floor(), math.ceil() などの追加の操作が定義されています。

---

## 整数型の追加メソッド

int 型は numbers.Integral の抽象基底クラスを実装しており、以下のような追加メソッドがあります。

### int.bit_length()

整数を 2 進数で表現するために必要なビット数（符号や先頭の 0 を除く）を返します。  
例:

```python
n = -37
bin(n)        # '-0b100101'
n.bit_length()  # 6
```

非ゼロの場合、k は 2**(k-1) <= abs(x) < 2**k を満たす唯一の正の整数です。  
（バージョン 3.1 追加）

### int.bit_count()

絶対値の 2 進数表現に含まれる 1 の数（人口カウント）を返します。  
例:

```python
n = 19
bin(n)        # '0b10011'
n.bit_count()  # 3
(-n).bit_count()  # 3
```

（バージョン 3.10 追加）

### int.to_bytes(length, byteorder='big', \*, signed=False)

整数を指定されたバイト数のバイト列に変換して返します。  
例:

```python
(1024).to_bytes(2, byteorder='big')
# b'\x04\x00'
```

引数の byteorder には 'big' または 'little' を指定し、signed が False の場合は負の整数はエラーとなります。  
（バージョン 3.2 追加、バージョン 3.11 でデフォルト引数が追加）

### classmethod int.from_bytes(bytes, byteorder='big', \*, signed=False)

与えられたバイト列から整数を生成して返します。  
例:

```python
int.from_bytes(b'\x00\x10', byteorder='big')  # 16
int.from_bytes(b'\x00\x10', byteorder='little')  # 4096
```

（バージョン 3.2 追加、バージョン 3.11 で byteorder のデフォルト引数追加）

### int.as_integer_ratio()

元の整数と同じ比率（常に分母は 1）の (numerator, denominator) タプルを返します。  
（バージョン 3.8 追加）

### int.is_integer()

常に True を返します。これは float.is_integer() とのダックタイプ互換のために存在します。  
（バージョン 3.12 追加）

---

## 浮動小数点型の追加メソッド

float 型は numbers.Real の抽象基底クラスを実装しており、以下のメソッドがあります。

### float.as_integer_ratio()

元の浮動小数点数と正確に等しい整数比 (numerator, denominator) を返します。  
※無限大の場合は OverflowError、NaN の場合は ValueError が発生します。

### float.is_integer()

浮動小数点数が有限で、整数値（小数部が 0）であれば True を返し、それ以外は False を返します。  
例:

```python
(-2.0).is_integer()  # True
(3.2).is_integer()   # False
```

また、浮動小数点数の 16 進数文字列表現への変換（hex()）および逆変換（fromhex()）のためのメソッドもあります。  
16 進数表現は、誤差なく浮動小数点数を表現できるため、デバッグや数値計算で有用です。

### float.hex()

浮動小数点数を 16 進数文字列に変換して返します。有限な数の場合、常に先頭に "0x" と末尾に "p" と指数が付加されます。

### classmethod float.fromhex(s)

16 進数文字列 s から浮動小数点数を生成して返します。  
文字列 s は、符号、"0x"、整数部、オプションの小数点および小数部、'p' と指数から構成されます。  
例:

```python
float.fromhex('0x3.a7p10')  # 3740.0
```

（バージョン 3.1 以降、キーワード引数対応などの変更あり）

---

## 数値型のハッシュ

数値 x と y（型が異なる場合も含む）について、x == y のときは必ず hash(x) == hash(y) となる必要があります。  
Python の数値型のハッシュは、あらゆる有理数に対して定義された数学的関数（固定素数 P による剰余計算）に基づいており、sys.hash_info.modulus でその素数が参照可能です。  
CPython では、32 ビットの C long を持つ環境では P = 2**31 - 1、64 ビットの場合は P = 2**61 - 1 が使われます。  
詳細なルールはドキュメント内のサンプルコードに示されています。

---

## ブール型 — bool

ブール値は真偽を表し、bool 型は True と False の 2 つの定数インスタンスのみを持ちます。  
組み込み関数 bool() を使えば、任意の値をブール値に変換できます。  
また、論理演算には and, or, not を使用します。  
ビット演算子 &, |, ^ をブール値に適用すると、論理的な and, or, xor と同じ結果となりますが、論理演算子の利用が推奨されます。  
※バージョン 3.12 以降、ビット反転演算子 ~ の使用は非推奨となり、Python 3.16 でエラーになる予定です。  
なお、bool は int のサブクラスであり、数値コンテキストでは False, True はそれぞれ 0, 1 として動作しますが、明示的に int() で変換することが望ましいです。

---

## イテレータ型

Python はコンテナ上の反復処理をサポートします。  
これは、ユーザー定義クラスでも反復処理をサポートできるよう、2 つの方法（**iter**() と **next**()）によって実装されています。  
シーケンス型は必ずこれらのメソッドを実装しています。

- **container.**iter**()**  
  イテレータオブジェクトを返します。返されたオブジェクトは **iter**() と **next**() を持たなければなりません。

- **iterator.**iter**()**  
  イテレータ自身を返します。これにより、for 文などで利用可能です。

- **iterator.**next**()**  
  次の要素を返し、要素がなくなれば StopIteration を発生させます。

一度 StopIteration を発生させたイテレータは、以降も必ず StopIteration を発生させなければなりません。

---

## ジェネレータ型

ジェネレータは、イテレータプロトコルを実装するための簡便な方法を提供します。  
もし container.**iter**() がジェネレータとして実装されていれば、自動的に **iter**() と **next**() を備えたジェネレータオブジェクトが返されます。  
yield 式に関する詳細は、ジェネレータのドキュメントを参照してください。

---

## シーケンス型 — list, tuple, range

基本的なシーケンス型は、リスト、タプル、および range オブジェクトの 3 つです。  
バイナリデータやテキスト文字列を扱うための追加のシーケンス型については、後述の専用セクションを参照してください。

### 共通のシーケンス操作

以下の表は、ほとんどのシーケンス型（可変・不変ともに）でサポートされる操作を示しています。  
シーケンス型の抽象基底クラス collections.abc.Sequence を用いると、カスタムシーケンスでこれらの操作を正しく実装しやすくなります。

（※表中、s や t は同じ型のシーケンス、n, i, j, k は整数、x は s に課される型・値の制約を満たす任意のオブジェクトを意味します。）

- **x in s**: s の中に x と等しい要素があれば True
- **s + t**: s と t の連結
- **s \* n**: s を n 回繰り返したシーケンス
- **s[i]**: 0 始まりの i 番目の要素
- **s[i:j]**, **s[i:j:k]**: スライス（各詳細はドキュメント参照）
- **len(s)**, **min(s)**, **max(s)**, **s.index(x, …)**, **s.count(x)** など

シーケンス同士の比較は、通常、要素ごとに辞書順に比較されます。

※注意事項として、負のインデックスは末尾からの参照、スライスは指定された範囲の要素を抽出する、などの基本動作があります。  
また、連結・繰り返し操作は不変シーケンスの場合、新しいオブジェクトを生成するため、効率に注意が必要です。

---

### 不変シーケンス型

不変シーケンス型では、mutable なシーケンスと異なり、hash() が実装される（たとえばタプルは辞書のキーとして使える）という違いがあります。  
ただし、不変シーケンス内にハッシュ不可能な値が含まれると、TypeError が発生します。

---

### 可変シーケンス型

可変シーケンス型では、以下のような操作が定義されています。  
（※collections.abc.MutableSequence を用いると、カスタムシーケンスでこれらを正しく実装しやすくなります。）

例：

- s[i] = x
- s[i:j] = t
- del s[i:j]
- s.append(x)
- s.clear()、s.copy()
- s.extend(t) または s += t
- s.insert(i, x)
- s.pop() または s.pop(i)
- s.remove(x)
- s.reverse()

※注意：スライス指定（s[i:j:k]）の場合、k が 1 でないときは t の長さがスライスの長さと一致する必要があります。  
また、pop() の省略形では末尾の要素が返され、remove() は見つからない場合 ValueError を発生させます。

（バージョン 3.3 から clear() と copy() が追加されました。）

---

## リスト

リストは、可変シーケンスであり、通常は同種の要素を格納するために使われます。

リストの作成方法:

- 空リスト: `[]`
- 複数の要素: `[a]`、`[a, b, c]`
- リスト内包表記: `[x for x in iterable]`
- コンストラクタ: `list()` または `list(iterable)`

※すでにリストが与えられた場合はコピーが作成されます。  
また、sorted() などの操作でもリストが生成されます。

リストは共通および可変シーケンス操作をすべて実装しており、以下の追加メソッドも提供します。

#### sort(\*, key=None, reverse=False)

リストをその場でソートします。

- key: 各要素から比較キーを抽出する 1 引数の関数
- reverse: True の場合、逆順にソート  
  ※このメソッドは副作用でリスト自体を変更し、ソート済みのリスト自体は返しません。  
  また、ソートは安定（同じ値の要素の順序は保持）であることが保証されています。  
  ※CPython では、ソート中にリストの変更や検査を行うと未定義の動作となります。（値が検出されれば ValueError が発生する場合もあります。）

---

## タプル

タプルは不変シーケンスであり、異種のデータ（あるいは不変で同種のデータ）を格納するために使われます。  
タプルの作成方法:

- 空タプル: `()`
- 単一要素タプル: `a,` または `(a,)`
- 複数要素: `a, b, c` または `(a, b, c)`
- コンストラクタ: `tuple()` または `tuple(iterable)`

※タプルの場合、実際には括弧ではなくカンマによってタプルが作られます。  
既にタプルが与えられた場合はそのまま返されます。

---

## range オブジェクト

range 型は、整数の不変シーケンスを表し、主に for ループなどで特定回数の繰り返しに用いられます。

range の作成方法:

- `range(stop)`
- `range(start, stop[, step])`

引数はすべて整数で、step が 0 の場合は ValueError が発生します。  
正の step の場合、r[i] = start + step \* i（ただし r[i] < stop を満たす）であり、負の場合は逆の条件となります。  
range オブジェクトは、その大きさにかかわらず常に小さいメモリを使用します（start, stop, step の値のみを保持）。

また、range は collections.abc.Sequence を実装しており、メンバーシップテスト、インデックス検索、スライシング、負のインデックスがサポートされています。  
（バージョン 3.2 ～ 3.3 での変更点についても記載あり）

---

## テキストシーケンス型 — str

文字列は Unicode コードポイントの不変シーケンスです。  
文字列リテラルはシングルクォート、ダブルクォート、トリプルクォートなどで表現できます。  
複数行にまたがるトリプルクォート文字列では、空白も含まれます。  
隣接する文字列リテラルは自動的に結合されます。  
また、str() コンストラクタにより他のオブジェクトから文字列を生成することもできます。  
文字列のインデックスやスライスは常に長さ 1 の文字列を返します（別途「文字」型は存在しません）。

文字列は多くのメソッドを持ち、さらに 2 種類の文字列フォーマット方法（str.format() や C の printf 風の % 演算子）をサポートします。  
以下は主要なメソッドの一部です。

- **capitalize()**: 先頭文字をタイトルケースに、残りを小文字に変換  
  （バージョン 3.8 以降、タイトルケースが適用されます）
- **casefold()**: より積極的な小文字化。たとえば 'ß' を "ss" に変換する。  
  （バージョン 3.3 追加）
- **center(width[, fillchar])**: 指定幅で中央寄せ、fillchar で埋める
- **count(sub[, start[, end]])**: 部分文字列 sub の非重複出現回数を返す
- **encode(encoding='utf-8', errors='strict')**: エンコードして bytes を返す
- **endswith()**、**find()**、**format()**、**index()**、**isalnum()**、**isalpha()**、**isascii()**（バージョン 3.7 追加）、**isdecimal()**、**isdigit()**、**islower()**、**isspace()**、**istitle()**、**isupper()**、**join()**、**ljust()**、**lower()**、**lstrip()**、**partition()**、**removeprefix()**（バージョン 3.9 追加）、**removesuffix()**（バージョン 3.9 追加）、**replace()**、**rfind()**、**rindex()**、**rjust()**、**rpartition()**、**rsplit()**、**rstrip()**、**split()**、**splitlines()**、**startswith()**、**strip()**、**swapcase()**、**title()**、**upper()**、**zfill()**  
  （各メソッドの詳細は原文の説明を参照してください）

さらに、printf 風の % 演算子によるフォーマットもサポートされています。  
% 演算子は、書式指定子に基づいて値を文字列に埋め込むもので、C 言語の sprintf() に類似します。  
詳細な構文（% から始まる変換指定子の構成要素など）も記載されています。  
※バージョン 3.5 以降、一部仕様の変更があります。

---

## バイナリシーケンス型 — bytes, bytearray, memoryview

バイナリデータを扱うための基本型は bytes（不変）と bytearray（可変）で、memoryview はバッファプロトコルによりコピーせずに内部データにアクセスできるようにします。

### Bytes オブジェクト

bytes オブジェクトは不変の単一バイトのシーケンスです。

- リテラルは b'...' の形式で記述します。
- 文字列リテラルと同様の書式ですが、ASCII 以外の文字はエスケープシーケンスで表現します。
- 作成方法: `bytes(10)`（ゼロ埋め）、`bytes(range(20))`、またはバッファプロトコルを通して。
- また、fromhex() クラスメソッドで 16 進数文字列から bytes オブジェクトを生成できます。  
  例:
  ```python
  bytes.fromhex('2Ef0 F1f2  ')  # b'.\xf0\xf1\xf2'
  ```
- hex() メソッドで逆変換も可能です。

※インデックスでは整数、スライスでは bytes オブジェクトが返されます。

### Bytearray オブジェクト

bytearray は bytes の可変版です。

- リテラル構文はなく、コンストラクタで生成します。  
  例: `bytearray()`, `bytearray(10)`, `bytearray(range(20))`
- fromhex(), hex() などのメソッドも bytes と同様です。
- インデックスは整数、スライスは bytearray が返されます。

### Bytes と Bytearray の共通操作

両者は共通のシーケンス操作をサポートし、相互に演算可能です。  
ただし、メソッドの引数としては文字列ではなく bytes-like オブジェクトを要求します。  
たとえば、replace() や split()、translate() などが定義されています。  
また、前述の removeprefix()/removesuffix() など（バージョン 3.9 追加）もサポートされます。  
※bytearray のメソッドは常に新しいオブジェクトを返し、in-place にはなりません。

### Memoryview オブジェクト

memoryview は、バッファプロトコルに対応するオブジェクトの内部データへ、コピーせずにアクセスするためのオブジェクトです。

- コンストラクタ: `memoryview(obj)`
- 1 要素は、オリジナルのオブジェクトの「原子単位」（通常は 1 バイト）を表しますが、array.array のように要素サイズが大きい場合もあります。
- インデックスやスライスがサポートされ、C 言語や Fortran 形式でのオーダー指定も可能です。
- 書き込み可能な場合、1 次元スライスへの代入が可能です。
- メソッドとして tobytes(), hex(), tolist(), toreadonly(), release(), cast() などがあり、各種属性（format, itemsize, ndim, shape, strides, readonly など）も定義されています。  
  （バージョン 3.2 ～ 3.8 での追加・変更点あり）

---

## 集合型 — set, frozenset

set オブジェクトは、ハッシュ可能な値の順序付けされていない集合です。

- 主な用途は、メンバーシップのテスト、重複除去、数学的集合演算（和、積、差、対称差）などです。
- 可変な set と不変な frozenset があり、frozenset はハッシュ可能なため辞書のキーなどに使えます。
- リテラルとしては、可変な集合は `{ 'jack', 'sjoerd' }` などで表現され、コンストラクタも利用可能です。
- また、集合間の演算子（|, &, -, ^ など）や、メソッド（update, intersection_update, difference_update, symmetric_difference_update, add, remove, discard, pop, clear など）もサポートされます。

---

## マッピング型 — dict

dict は、ハッシュ可能なキーと任意の値を対応付ける可変マッピング型です。

- キーとして使える値は、ハッシュ可能なものでなければなりません。
- 作成方法は、リテラル（例: `{'jack': 4098, 'sjoerd': 4127}`）、dict 内包表記、コンストラクタ（`dict()`, `dict(foo=100, bar=200)` など）があります。
- キーの重複があれば、最後の値が有効となります。
- 主な操作として、キーの一覧取得、長さ、キーによるアクセス、追加、削除、メンバーシップテスト、イテレータ生成、clear(), copy(), fromkeys(), get(), items(), keys(), pop(), popitem(), setdefault(), update(), values() などがあります。
- Python 3.7 以降、辞書は挿入順序を保持し、また 3.8 以降は reversed() による反転もサポートされています。
- 辞書のビュー（keys(), values(), items() で返されるオブジェクト）は動的に辞書の内容を反映し、set のような集合演算も可能です。  
  （バージョン 3.10 では mapping 属性で読み取り専用の MappingProxyType を取得可能）

---

## コンテキストマネージャ型

with 文で使用する実行時コンテキストは、コンテキストマネージャによって定義され、以下の 2 つのメソッドにより実装されます。

- ****enter**()**  
  コンテキストに入る際に呼ばれ、with 節の as 句にバインドされる値を返します。  
  例：ファイルオブジェクトは **enter**() で自身を返します。

- ****exit**(exc_type, exc_val, exc_tb)**  
  コンテキストを抜ける際に呼ばれ、例外が発生していればその情報が渡され、例外の抑制を示すブール値を返します。  
  ※このメソッド内で例外を再送出してはならず、正常終了の場合は False を返します。

また、contextlib モジュールや contextlib.contextmanager デコレータにより、ジェネレータ関数から簡単にコンテキストマネージャを作成できます。

---

## 型注釈用の型 — Generic Alias, Union

型注釈のための組み込み型として、Generic Alias と Union があります。

### Generic Alias 型

GenericAlias オブジェクトは、クラスをサブスクリプトすることで生成され、たとえば list[int] や dict[str, list[int]] などがこれに該当します。

- これらは主に型注釈用に使われ、実行時には型パラメータは消去されます。
- **origin**, **args**, **parameters** などの属性を持ち、詳細はドキュメントに記載されています。

### Union 型

Union 型は、X | Y | … の形式で表現され、型注釈で「X または Y」を意味します。

- これは typing.Union[X, Y] と同等です。
- 例:
  ```python
  def square(number: int | float) -> int | float:
      return number ** 2
  ```
- 順序は無視され、重複は除去されます。
- Optional 型は Union[T, None] と同等です。
- なお、実行時にパラメータ化されたジェネリック型との isinstance() チェックはサポートされません。
- Union 型自体は types.UnionType からアクセス可能ですが、インスタンス化はできません。
- （バージョン 3.10 追加）

---

## その他の組み込み型

インタプリタは、上記以外にもさまざまな型をサポートします。

- **モジュール**: m.name により属性アクセスが可能で、特殊属性 **dict** を持ちます。
- **クラスおよびクラスのインスタンス**: 詳細は「オブジェクト、値、型」や「クラス定義」を参照。
- **関数**: 定義により生成され、呼び出しが唯一の操作です。組み込み関数とユーザー定義関数があります。
- **メソッド**: インスタンスからアクセスすると「バウンドメソッド」となり、**self** と **func** 属性を持ちます。
- **コードオブジェクト**: compile() により生成され、関数の **code** 属性として参照できます。
- **型オブジェクト**: type() により取得でき、標準モジュール types に名前が定義されています。
- **ヌルオブジェクト**: 明示的に返されない関数は None を返します。
- **Ellipsis オブジェクト**: スライス記法などで使われ、唯一の Ellipsis インスタンスがあります。
- **NotImplemented オブジェクト**: サポートしていない演算子で返され、唯一の NotImplemented インスタンスがあります。
- **内部オブジェクト**: スタックフレーム、トレースバック、スライスオブジェクトなど（詳細は標準型階層を参照）。

---

## 特殊属性

実装は、各オブジェクト型に対して以下のような読み取り専用の特殊属性を追加しています。

- ****name****: クラス、関数、メソッドなどの名前
- ****qualname****: 修飾付きの名前（バージョン 3.3 追加）
- ****module****: 定義されたモジュールの名前
- ****doc****: ドキュメンテーション文字列（なければ None）
- ****type_params****: ジェネリックなクラスや関数の型パラメータ（非ジェネリックの場合は空タプル）  
  （バージョン 3.12 追加）

---

## 整数文字列変換の長さ制限

CPython では、DoS 攻撃を防ぐために、int と str（または bytes）間の変換において、デフォルトで 4300 桁の制限が設けられています。

- 10 進数以外（16 進、8 進、2 進）は制限なしです。
- 制限は sys.int_info.default_max_str_digits および sys.int_info.str_digits_check_threshold で参照でき、  
  sys.get_int_max_str_digits() / sys.set_int_max_str_digits() により変更可能です。
- 環境変数 PYTHONINTMAXSTRDIGITS や -X int_max_str_digits オプションで起動前に設定することも可能です。
- 制限を下げすぎると、ソース中の定数リテラルがパースエラーとなる可能性があるため注意が必要です。  
  （バージョン 3.11 追加）

---

## 影響を受ける API

この制限は、以下の変換に適用されます：

- int(string)（10 進数の場合や 10 進数以外で非 2 の冪の場合）
- str(integer) や repr(integer) など
- f-string や format() など 10 進数変換に関わるもの

一方、

- int(string, base)（base が 2,4,8,16,32 の場合）
- int.from_bytes(), int.to_bytes()
- hex(), oct(), bin()  
  などの変換は制限対象外です。

---

## 制限の設定方法

起動前に環境変数 PYTHONINTMAXSTRDIGITS またはコマンドラインオプション -X int_max_str_digits で設定できます。  
また、プログラム内では sys.get_int_max_str_digits() / sys.set_int_max_str_digits() を用いて変更可能です。  
※環境変数と -X オプションの両方が指定された場合、-X オプションが優先されます。

---

## 推奨設定

デフォルトの 4300 桁はほとんどの用途で十分と考えられますが、必要に応じてエントリーポイントで設定してください。  
例:

```python
import sys
if hasattr(sys, "set_int_max_str_digits"):
    upper_bound = 68000
    lower_bound = 4004
    current_limit = sys.get_int_max_str_digits()
    if current_limit == 0 or current_limit > upper_bound:
        sys.set_int_max_str_digits(upper_bound)
    elif current_limit < lower_bound:
        sys.set_int_max_str_digits(lower_bound)
```

※完全に無制限にする場合は 0 を設定します。

---

_© Copyright 2001–2025, Python Software Foundation_  
このページは Python Software Foundation License Version 2 の下でライセンスされています。  
ドキュメント内の例、レシピその他のコードは、さらに Zero Clause BSD License の下でライセンスされています。  
詳細は History and License をご参照ください。

Python Software Foundation は非営利法人です。どうぞご寄付をお願いいたします。

最終更新: 2025 年 2 月 28 日 (08:46 UTC)  
（バグを発見しましたか？）  
Sphinx 8.2.1 を使用して作成

---

以上が、提供されたドキュメント全体の日本語訳です。  
（各セクション内の細かなコード例やバージョンごとの変更点についても、原文に沿って訳出しております。）
