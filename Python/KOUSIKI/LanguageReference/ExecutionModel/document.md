以下は、上記の「4. Execution model」の英語ドキュメントをできるだけ忠実に、かつ日本語として読みやすく翻訳・解説したものです。各節ごとに主要なポイントと注意点を強調しています。

---

# 4. 実行モデル

Python プログラムは「コードブロック」から構成され、各コードブロックはひとつの単位として実行されます。コードブロックの実行は「実行フレーム」内で行われ、フレームにはデバッグ情報などの管理情報が含まれ、ブロックの実行完了後の処理（次にどこから実行を再開するか）を決定します。

---

## 4.1. プログラムの構造

Python プログラムは、以下のような複数のコードブロックから構成されます。

- **モジュール:** ファイル全体や標準入力・-c オプション、-m オプションで実行されるスクリプト全体がひとつのブロックとなる。
- **関数本体:** 関数定義内のコードブロック。
- **クラス定義:** クラスの本体もひとつのコードブロックです。
- **対話型入力:** インタラクティブに入力された各コマンドもコードブロックです。
- **eval() や exec() に渡された文字列:** これもひとつのコードブロックとして実行されます。

各コードブロックは実行フレーム内で処理され、フレームは実行が完了した後の継続先（次に実行する場所など）を保持します。

---

## 4.2. 名前とバインディング

Python では「名前」はオブジェクトを参照するためのラベルです。名前は「バインディング（束縛）」操作によってオブジェクトに結びつけられます。

### 4.2.1. 名前の束縛

以下のような構文が名前の束縛を行います：

- **関数の形式引数:** 関数定義における引数名は、その関数内でローカル変数として束縛されます。
- **クラス定義:** クラス名はクラスブロック内で束縛され、またクラスブロック内で定義された名前は、そのクラスの属性（クラス変数）となります。
- **関数定義:** 関数定義時に関数名が束縛されます。
- **代入式:** 代入文により、識別子が対象オブジェクトに束縛されます。たとえば、単純な代入文、リスト内包表記、for 文のループ変数、with 文の as 節、except 節、構造的パターンマッチの as パターン、キャプチャパターンなどが該当します。
- **import 文:** たとえば、`import module` や `from module import *`（ただし、先頭にアンダースコアがつく名前は除く）。
- **type 文、型パラメータリスト:** 型ヒント関連の構文でも名前が束縛されます。
- **del 文のターゲット:** 削除対象の名前は「束縛された名前」として扱われます（ただし、実際にはその名前のバインディングが解除される）。

各代入や import 文は、関数やクラス定義またはモジュールレベル（最上位のコードブロック）で実行されます。

- ブロック内で名前が束縛される場合、そのブロックのローカル変数となります（ただし、global や nonlocal 宣言がある場合は例外）。
- モジュールレベルで束縛された名前はグローバル変数となります。
- もしブロック内で定義されていない名前が使用される場合、それは自由変数として解決され、最終的にグローバル変数や builtins から検索されます。

### 4.2.2. 名前の解決

名前が参照される際、その名前は以下のルールに従い解決されます。

- **スコープ（有効範囲）:**  
  あるブロック内で名前が定義されていれば、そのスコープはそのブロック全体を含みます。関数ブロックの場合、内側のブロック（例えば内包表記など）も含まれますが、同名の名前が再束縛されると、内側の名前が優先されます。

- **名前解決のルール:**  
  名前が使用される際、最も内側（最も近い）から順にスコープが検索され、見つかったものが使用されます。この全体のスコープの集合を「環境」と呼びます。

- **名前が見つからない場合:**  
  名前が全く見つからなければ、NameError が送出されます。  
  関数内でローカル変数として使われる名前が、バインド前に使用されると UnboundLocalError（NameError のサブクラス）が発生します。

- **global 宣言と nonlocal 宣言:**

  - `global` 宣言により、ブロック内での名前の使用はグローバル（モジュール）変数として扱われます。
  - `nonlocal` 宣言により、最も近い外側の関数スコープ内の変数が参照されます。

- **クラス定義の場合:**  
  クラス定義内で定義された名前のスコープは、クラスブロック内に限定され、メソッド内では直接参照できません（ただし、暗黙の `__class__` セルを通じてアクセス可能）。

### 4.2.3. アノテーションスコープ

アノテーション（型ヒント）のためのスコープは、通常の関数スコープに似ていますが、いくつかの例外があります。

- **対象:**
  - ジェネリック型エイリアスの型パラメータリスト
  - ジェネリック関数のアノテーション
  - ジェネリッククラスの型パラメータリストおよび基底クラスの評価
- **特徴:**
  - アノテーションスコープ内では、外側のクラスの名前空間にアクセスできる（クラスメソッド内ではアクセスできない通常の関数スコープとは異なる）。
  - アノテーション内の式には、yield, await, 代入式 (:=) などは使えません。
  - アノテーションスコープで定義された名前は、内側のスコープで nonlocal によって再束縛できません。
- **実行タイミング:**  
  アノテーションは遅延評価される場合があり、必要になるまで評価されません（後述の「遅延評価」参照）。

### 4.2.4. 遅延評価

型エイリアスや型変数の境界、制約、既定値は、遅延評価されます。  
つまり、これらは作成時には評価されず、属性アクセスなどが行われたときに初めて評価されます。  
これにより、まだ定義されていない型への参照や、相互再帰的な型エイリアスが可能となります。

> **例:**
>
> ```python
> type Alias = 1/0
> # エイリアス作成時にはエラーは発生しないが、属性にアクセスすると ZeroDivisionError
> Alias.__value__
> ```

この動作は、主にアノテーション内での参照解決を柔軟にするためのものです。

### 4.2.5. ビルトインと制限付き実行

CPython の実装では、`__builtins__` は内部の実装ディテールであり、通常は直接操作すべきではありません。  
ビルトイン名前空間は、コードブロックのグローバル名前空間内の `__builtins__` という名前を参照することで決まります。

- **main** モジュールの場合、`__builtins__` は組み込みモジュール `builtins` そのもの
- 他のモジュールの場合、`__builtins__` は `builtins` モジュールの辞書が使われます。

---

## 4.2.6. 動的機能との相互作用

自由変数（ローカルスコープに存在しない変数）の解決は、コンパイル時ではなく実行時に行われます。  
たとえば、次のコードは 42 を出力します。

```python
i = 10
def f():
    print(i)
i = 42
f()  # 42 が出力される
```

また、`eval()` や `exec()` は、呼び出し側のローカル・グローバル名前空間を部分的にしか利用できません。  
たとえば、free 変数は最も近い囲みの名前空間ではなく、グローバル名前空間から解決されます。  
これらの関数には、グローバルおよびローカル名前空間を上書きするための引数が用意されています。

---

## 4.3. 例外

**概要:**  
例外は、コードブロックの通常の制御フローから抜け出し、エラーや異常な状況に対処するための仕組みです。

- **例外の発生:**  
  Python インタプリタは、ゼロ除算などの実行時エラーを検出すると例外を発生させます。  
  また、プログラマは `raise` 文を用いて明示的に例外を発生させることもできます。

- **例外の処理:**  
  `try … except` 文を用いて例外を捕捉し、適切な処理（エラーメッセージの表示、リソースの解放など）を行います。  
  `finally` 節は例外の有無にかかわらず必ず実行されるため、後処理（クリーンアップ）に利用されます。

- **エラーハンドリングのモデル:**  
  Python は「終了」モデルのエラーハンドリングを採用しています。  
  すなわち、例外ハンドラは発生した例外に対して何が起こったかを知り、外側のブロックで実行を続行しますが、根本原因の修復と再試行は行いません（必要ならばコードを再実行する必要があります）。

- **未処理の例外:**  
  例外がどのレベルのコードブロックでも処理されなかった場合、インタプリタはプログラムの実行を終了するか、対話型ループに戻ります。  
  また、例外が `SystemExit` でない限り、スタックトレースが表示されます。

- **例外の識別:**  
  例外はクラスのインスタンスとして表現されます。  
  `except` 節では、例外インスタンスのクラス（またはその非仮想基底クラス）に一致するかどうかで処理が決まります。  
  ハンドラ内で例外インスタンスを変数に束縛することができ、追加情報を参照可能です。

> **注意:**  
> 例外メッセージの内容は Python のバージョン間で変わる可能性があるため、コードでメッセージの内容に依存するべきではありません。

---

## まとめ

このセクション「4. Execution model」では、Python プログラムの実行構造や、名前解決とバインディングの仕組み、さらに例外処理のモデルについて説明されています。

- プログラムはコードブロックとして構成され、各ブロックは実行フレーム内で処理される。
- 名前はバインディング操作によってオブジェクトに結び付けられ、スコープと環境に基づいて解決される。
- アノテーションスコープや遅延評価により、型ヒントなどの高度な機能もサポートされる。
- 例外は、エラー発生時に通常の制御フローを中断し、try…except や finally で処理する仕組みを提供する。

これらの仕組みを理解することで、Python プログラムの実行やエラー処理、名前解決の深い理解につながり、より堅牢で読みやすいコードを書くための基礎となります。

---

ぜひ、上記の各コード例や説明を元に実際にコードを書いて動作確認しながら、Python の実行モデルの理解を深めてください。
