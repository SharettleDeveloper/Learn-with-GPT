以下は、提供されたドキュメントの日本語訳です。

---

# 7. 単純文

単純文（simple statement）は、1 つの論理行内に収まる文です。複数の単純文をセミコロンで区切って同じ行に記述することも可能です。単純文の構文は以下の通りです：

```
simple_stmt ::= expression_stmt
              | assert_stmt
              | assignment_stmt
              | augmented_assignment_stmt
              | annotated_assignment_stmt
              | pass_stmt
              | del_stmt
              | return_stmt
              | yield_stmt
              | raise_stmt
              | break_stmt
              | continue_stmt
              | import_stmt
              | future_stmt
              | global_stmt
              | nonlocal_stmt
              | type_stmt
```

---

## 7.1. 式文（Expression statements）

式文は、主に対話的に値を計算して書き出すため、または意味のある結果を返さない手続き（Python では手続きは通常 `None` を返す）の呼び出しに用いられます。他の用途も許され、時には有用です。式文の構文は以下の通りです：

```
expression_stmt ::= starred_expression
```

式文では、式リスト（単一の式またはコンマで区切られた複数の式によるタプル）が評価されます。対話モードでは、結果が `None` でない場合、組み込み関数 `repr()` を用いて文字列に変換され、その文字列が標準出力に単独の行として書き出されます（ただし結果が `None` の場合は出力されません）。

---

## 7.2. 代入文

代入文は、名前を値に（再）束縛したり、変更可能なオブジェクトの属性や要素を変更するために使用されます：

```
assignment_stmt ::= (target_list "=")+ (starred_expression | yield_expression)
target_list     ::= target ("," target)* [","]
target          ::= identifier
                  | "(" [target_list] ")"
                  | "[" [target_list] "]"
                  | attributeref
                  | subscription
                  | slicing
                  | "*" target
```

（`attributeref`、`subscription`、`slicing` の構文定義については「プリマリ」セクションを参照してください。）

代入文は、式リスト（単一の式またはコンマ区切りのリスト、後者はタプルとなる）を評価し、その結果となる単一のオブジェクトを左側のターゲットリストに左から右の順に代入します。

代入はターゲットの形（リスト）に応じて再帰的に定義されます。もしターゲットが変更可能なオブジェクト（属性参照、添字、スライス）の一部である場合、その変更可能オブジェクトが最終的に代入を実行し、その妥当性を判断します。オブジェクトの型ごとに規則と例外が定義されており（標準の型階層のセクションを参照）、代入が不適切であれば例外が発生します。

1. ターゲットリストがカンマで区切られていない単一のターゲット（括弧に囲まれていてもよい）の場合、そのオブジェクトがそのターゲットに代入されます。

2. それ以外の場合：
   - もしターゲットリストに「_」で前置されたターゲット（「starred target」と呼ばれる）が含まれる場合：  
     オブジェクトは、ターゲットリスト内のターゲット数（「_」付きターゲットを除く）以上の要素を持つ反復可能なオブジェクトでなければなりません。反復可能オブジェクトの最初の方の要素が「_」の前のターゲットに左から順に代入され、最後の方の要素が「_」の後のターゲットに代入されます。残りの要素のリストが「\*」付きターゲットに代入されます（リストは空でも構いません）。
   - それ以外の場合：  
     オブジェクトはターゲットリストと同じ数の要素を持つ反復可能なオブジェクトでなければならず、各要素が対応するターゲットに左から順に代入されます。

単一のターゲットへの代入は以下のように再帰的に定義されます：

- **ターゲットが識別子（名前）の場合**：

  - その名前が現在のコードブロック内で `global` または `nonlocal` ステートメントに含まれていなければ、その名前は現在のローカル名前空間に束縛されます。
  - そうでなければ、その名前はグローバル名前空間、または `nonlocal` により決定された外側の名前空間に束縛されます。
  - 既に束縛されている場合、名前は再束縛されます。これにより、以前にその名前に束縛されていたオブジェクトの参照カウントがゼロになり、オブジェクトが解放され、そのデストラクタ（存在する場合）が呼ばれることがあります。

- **ターゲットが属性参照の場合**：

  - まず参照の主式が評価され、代入可能な属性を持つオブジェクトを返す必要があります。そうでなければ `TypeError` が発生します。その後、そのオブジェクトに対して、指定された属性に代入するよう依頼します。代入できない場合、例外（通常は `AttributeError`）が発生します。  
    ※ 注意：オブジェクトがクラスのインスタンスであり、代入文の左右両方で属性参照が使用される場合、右辺の式 `a.x` はインスタンス属性または（存在しない場合）クラス属性のどちらかにアクセスできます。しかし、左辺の `a.x` は常にインスタンス属性として設定され、必要に応じて新たに作成されます。したがって、左右の `a.x` は必ずしも同じ属性を参照するとは限りません。例えば：

    ```python
    class Cls:
        x = 3             # クラス変数
    inst = Cls()
    inst.x = inst.x + 1   # inst.x は 4 になり、Cls.x は 3 のまま
    ```

    この記述は、`property()` などで作成されたディスクリプタ属性には必ずしも適用されません。

- **ターゲットが添字の場合**：

  - まず参照の主式が評価され、変更可能なシーケンスオブジェクト（リストなど）またはマッピングオブジェクト（辞書など）を返す必要があります。その後、添字の式が評価されます。
  - もし主式が変更可能なシーケンスオブジェクト（リストなど）を返す場合、添字は整数でなければならず、負の場合はシーケンスの長さが加算されます。得られた値は、0 以上でシーケンスの長さ未満の整数でなければならず、そのインデックスに対して代入が行われます。インデックスが範囲外の場合、`IndexError` が発生します（シーケンスへの添字代入ではリストに新しい項目を追加することはできません）。
  - もし主式がマッピングオブジェクト（辞書など）を返す場合、添字はマッピングのキーの型と互換性がある必要があり、添字はそのキーに対応する値として代入されます。すでに同じキーが存在する場合は上書きされ、存在しなければ新たにキーと値のペアが挿入されます。  
    ユーザー定義のオブジェクトの場合、`__setitem__()` メソッドが適切な引数で呼び出されます。

- **ターゲットがスライスの場合**：
  - まず参照の主式が評価され、変更可能なシーケンスオブジェクト（リストなど）を返す必要があります。代入されるオブジェクトは同じ型のシーケンスオブジェクトでなければなりません。次に、下限および上限の式が評価され（存在する場合は評価）、デフォルト値はそれぞれ 0 およびシーケンスの長さとなります。これらの境界は整数に評価され、もしどちらかが負の場合はシーケンスの長さが加算されます。その後、得られた境界は 0 からシーケンスの長さ（含む）の範囲に切り詰められ、シーケンスはそのスライスを代入されたシーケンスの項目で置き換えます。スライスの長さと代入されるシーケンスの長さは異なる場合があり、ターゲットシーケンスの長さが変更されることもあります（ただし、ターゲットシーケンスがその変更を許容する場合に限る）。

※ CPython の実装上の詳細：現在の実装では、ターゲットの構文は式と同じとみなされ、不正な構文はコード生成段階で拒否されるため、詳細なエラーメッセージが生成されません。

なお、代入の定義は左辺と右辺の「同時」的な割り当てを意味しています（例えば、`a, b = b, a` は 2 つの変数を入れ替えます）が、同じコレクション内のターゲット間の重複は左から右の順に評価されるため、混乱を招く場合があります。たとえば、以下のプログラムは `[0, 2]` を出力します：

```python
x = [0, 1]
i = 0
i, x[i] = 1, 2         # まず i が更新され、その後 x[i] が更新される
print(x)
```

参照: PEP 3132 - 拡張イテラブルのアンパッキング

---

## 7.2.1. 拡張代入文

拡張代入は、2 項演算子と代入文を 1 つの文に組み合わせたものです：

```
augmented_assignment_stmt ::= augtarget augop (expression_list | yield_expression)
augtarget                 ::= identifier | attributeref | subscription | slicing
augop                     ::= "+=" | "-=" | "*=" | "@=" | "/=" | "//=" | "%=" | "**="
                            | ">>=" | "<<=" | "&=" | "^=" | "|="
```

（最後の 3 つの記号についての構文定義は「プリマリ」セクションを参照）

拡張代入では、まずターゲットが評価され（通常の代入文と異なり、アンパッキングはできません）、その後式リストが評価され、2 つのオペランドに対してその型に応じた二項演算が実行され、結果が元のターゲットに代入されます。ターゲットは一度だけ評価されます。

例えば、`x += 1` という拡張代入文は、ほぼ同等の効果を持つ `x = x + 1` と書き換えることができます。ただし、拡張代入では `x` の評価が 1 度だけで済む点や、可能な場合には実際の操作がインプレースで実行され、すなわち新しいオブジェクトを生成してターゲットに代入するのではなく、既存のオブジェクトが直接変更される点が異なります。

また、通常の代入と異なり、拡張代入では左辺が先に評価され、その後右辺が評価されます。たとえば、`a[i] += f(x)` では、まず `a[i]` が参照され、次に `f(x)` が評価され、加算が行われ、最後に結果が `a[i]` に書き戻されます。

属性参照に対するターゲットの場合、通常の代入と同じ注意点（クラス属性とインスタンス属性の関係）が適用されます。

---

## 7.2.2. 注釈付き代入文

注釈付き代入は、変数または属性の注釈と、任意の代入文を 1 つの文に組み合わせたものです：

```
annotated_assignment_stmt ::= augtarget ":" expression
                              ["=" (starred_expression | yield_expression)]
```

通常の代入文との違いは、単一のターゲットしか許されない点です。

- ターゲットが単純（括弧に囲まれていない単一の名前）である場合、クラスまたはモジュールスコープでの注釈は、特別なクラスまたはモジュール属性 `__annotations__` に評価結果として保存されます。これは、変数名（プライベートな場合は名前マングリングされたもの）から注釈の評価結果への辞書となります。この属性は書き換え可能で、静的に注釈が見つかった場合、クラスまたはモジュールの本体の実行開始時に自動的に作成されます。

- ターゲットが単純でない場合（属性、添字、または括弧で囲まれた名前）の場合、注釈はクラスまたはモジュールスコープ内で評価されますが、保存はされません。

- 関数スコープ内で名前に注釈が付けられている場合、その名前はそのスコープのローカル変数となります。関数スコープ内では注釈は評価されず、保存もされません。

右辺が存在する場合、注釈付き代入は（該当する場合）注釈を評価する前に実際の代入を行います。右辺が存在しない場合、式ターゲットの最後の `__setitem__()` または `__setattr__()` の呼び出し以外は評価されます。

参照: PEP 526 - 変数注釈の構文

また、PEP 484（型ヒント）では、クラス変数やインスタンス変数の型注釈をコメントではなく標準的な構文で記述する方法が導入されています。

※ 3.8 以降、注釈付き代入では通常の代入と同じ式が右辺に使用可能になりました。以前は、タプル表現など一部の式が構文エラーとなっていました。

---

## 7.3. assert 文

`assert` 文は、プログラムにデバッグ用の主張を挿入するための便利な方法です：

```
assert_stmt ::= "assert" expression ["," expression]
```

単純な形 `assert expression` は、次のコードと同等です：

```python
if __debug__:
    if not expression: raise AssertionError
```

拡張形 `assert expression1, expression2` は、次のコードと同等です：

```python
if __debug__:
    if not expression1: raise AssertionError(expression2)
```

これらの同等性は、`__debug__` と `AssertionError` が組み込み変数であることを前提としています。実装上、通常の条件下では組み込み変数 `__debug__` は `True` となり、最適化オプション（-O）が指定された場合は `False` になります。最適化が有効な場合、assert 文のためのコードは生成されません。

なお、失敗した式のソースコードをエラーメッセージに含める必要はなく、スタックトレースの一部として表示されます。

`__debug__` への代入は許されません。組み込み変数の値は、インタプリタ起動時に決定されます。

---

## 7.4. pass 文

```
pass_stmt ::= "pass"
```

`pass` は何もしないヌル操作です。文法上文が必要な箇所で実行するコードがない場合のプレースホルダーとして有用です。例えば：

```python
def f(arg): pass    # （まだ実装されていない）何もしない関数

class C: pass       # （まだ実装されていない）メソッドがないクラス
```

---

## 7.5. del 文

```
del_stmt ::= "del" target_list
```

`del` は、代入文の定義に非常に似た再帰的な定義に基づいてターゲットを削除します。詳細を全て記述する代わりに、以下のポイントに留意してください。

- ターゲットリストの各ターゲットは、左から右の順に削除されます。

- 名前の削除は、該当する名前の束縛をローカルまたはグローバル名前空間から削除します。もし名前が束縛されていなければ `NameError` 例外が発生します。

- 属性参照、添字、スライスの削除は、主オブジェクトに処理が委ねられます。特にスライスの削除は、対象の型に応じた空のスライスの代入と同等となります（ただし、これもオブジェクト側の判断に依存します）。

※ Python 3.2 以降、自由変数としてネストされたブロック内に現れる名前であっても、ローカル名前空間からの削除が可能になりました。

---

## 7.6. return 文

```
return_stmt ::= "return" [expression_list]
```

`return` 文は、関数定義内に文法的に含まれていなければならず、ネストされたクラス定義内では使用できません。

- 式リストが存在する場合、そのリストが評価され、存在しない場合は `None` が代入されます。

- `return` は現在の関数呼び出しを、評価された式リスト（または `None`）を返して終了させます。

- `try` 文の `finally` 節内から `return` が行われる場合、実際に関数を抜ける前に `finally` 節が実行されます。

- ジェネレータ関数内での `return` 文は、ジェネレータが終了したことを示し、`StopIteration` 例外が発生します。返された値（存在する場合）は、`StopIteration.value` 属性として保持されます。

- 非同期ジェネレータ関数内では、空の `return` 文はジェネレータの終了を示し、`StopAsyncIteration` が発生します。非空の `return` 文は構文エラーとなります。

---

## 7.7. yield 文

```
yield_stmt ::= yield_expression
```

`yield` 文は、意味的には `yield` 式と同等です。`yield` 文を使用することで、同等の `yield` 式文を書く際に必要となる括弧を省略できます。例えば、以下の `yield` 文：

```python
yield <expr>
yield from <expr>
```

は、以下の `yield` 式文と同等です：

```python
(yield <expr>)
(yield from <expr>)
```

`yield` 式および文は、ジェネレータ関数を定義する際にのみ使用され、ジェネレータ関数の本体内でのみ利用されます。関数定義内で `yield` を使用するだけで、その定義は通常の関数ではなくジェネレータ関数として扱われます。

詳しい `yield` の意味論については「yield 式」セクションを参照してください。

---

## 7.8. raise 文

```
raise_stmt ::= "raise" [expression ["from" expression]]
```

- 式が何も与えられていない場合、`raise` は現在処理中の例外（アクティブな例外）を再発生させます。アクティブな例外が存在しなければ、`RuntimeError` 例外が発生します。

- そうでない場合、最初の式が例外オブジェクトとして評価されます。これは `BaseException` のサブクラスまたはそのインスタンスでなければなりません。もしクラスが指定された場合、必要に応じて引数なしでインスタンス化され、その例外インスタンスが得られます。

- 例外の型は、例外インスタンスのクラスであり、値はそのインスタンスそのものです。

通常、例外が発生すると、トレースバックオブジェクトが自動的に生成され、例外の `__traceback__` 属性に付与されます。`with_traceback()` メソッドを用いると、トレースバックを自前で設定しながら例外を作成することができます。例：

```python
raise Exception("foo occurred").with_traceback(tracebackobj)
```

`from` 節は例外のチェーンを指定するために使用されます。指定された場合、2 番目の式は他の例外クラスまたはインスタンスでなければなりません。もし例外インスタンスであれば、発生した例外に `__cause__` 属性として添付されます（この属性は書き換え可能です）。例外クラスが指定された場合は、そのクラスをインスタンス化し、その結果の例外インスタンスが `__cause__` 属性に添付されます。もし発生した例外が処理されなければ、両方の例外が出力されます。

例えば：

```python
try:
    print(1 / 0)
except Exception as exc:
    raise RuntimeError("Something bad happened") from exc
```

この場合のトレースバックは、最初の例外（`ZeroDivisionError`）が直接の原因となり、その後に `RuntimeError` が発生したことを示します。

同様の仕組みは、既に例外処理中の状態で新たな例外が発生した場合にも暗黙的に働き、前の例外は新たな例外の `__context__` 属性に添付されます。

例外チェーンを明示的に抑制するには、`from` 節で `None` を指定します。例：

```python
try:
    print(1 / 0)
except:
    raise RuntimeError("Something bad happened") from None
```

※ 3.3 以降、`raise X from Y` で `Y` に `None` を指定することが可能になりました。また、例外の自動表示されるコンテキストを抑制するために `__suppress_context__` 属性が追加されました。

3.11 以降、except 節内でアクティブな例外のトレースバックが変更された場合、後の `raise` 文は変更後のトレースバックを伴って例外を再発生させます（以前は捕捉時のトレースバックが再利用されていました）。

---

## 7.9. break 文

```
break_stmt ::= "break"
```

`break` 文は、`for` または `while` ループ内に文法的に含まれていなければならず、そのループ内の関数またはクラス定義内では使用できません。  
`break` は、最も内側のループを終了させ、もしループに `else` 節が存在する場合はそれをスキップします。

なお、`break` によって `try` 文の `finally` 節を抜ける場合、`finally` 節はループを抜ける前に実行されます。

また、`for` ループで `break` によって終了した場合、ループ制御変数はその時点の値を保持します。

---

## 7.10. continue 文

```
continue_stmt ::= "continue"
```

`continue` 文は、`for` または `while` ループ内に文法的に含まれていなければならず、そのループ内の関数またはクラス定義内では使用できません。  
`continue` は、最も内側のループの次の繰り返しに進みます。

また、`continue` が `try` 文の `finally` 節を抜ける場合、`finally` 節は次のループサイクルを開始する前に実行されます。

---

## 7.11. import 文

```
import_stmt     ::= "import" module ["as" identifier] ("," module ["as" identifier])*
                  | "from" relative_module "import" identifier ["as" identifier]
                    ("," identifier ["as" identifier])*
                  | "from" relative_module "import" "(" identifier ["as" identifier]
                    ("," identifier ["as" identifier])* [","] ")"
                  | "from" relative_module "import" "*"
module          ::= (identifier ".")* identifier
relative_module ::= "."* module | "."+
```

基本的な `import` 文（`from` 節を伴わないもの）は、以下の 2 段階で実行されます：

1. モジュールを検索し、必要に応じてロードおよび初期化する。
2. インポート文が現れるスコープのローカル名前空間に名前を定義する。

複数の節がカンマで区切られている場合、これらの 2 段階の処理は各節ごとに個別に実行されます。すなわち、あたかも各節が個別の import 文であったかのように処理されます。

モジュールの取得に成功すれば、ローカル名前空間に以下のいずれかの方法でバインドされます：

- モジュール名の後に `as` が続く場合、`as` の後に続く名前に直接インポートされたモジュールがバインドされます。
- 名前が指定されていない場合、かつインポートされるモジュールがトップレベルモジュールである場合は、そのモジュール名がローカル名前空間にインポートされたモジュールへの参照としてバインドされます。
- インポートされるモジュールがトップレベルモジュールでない場合、モジュールを含むトップレベルパッケージの名前がローカル名前空間にバインドされ、そのトップレベルパッケージを通してインポートされたモジュールにアクセスする必要があります。

`from` 形式の場合は、以下のプロセスが行われます：

1. `from` 節で指定されたモジュールを見つけ、必要に応じてロードおよび初期化する。
2. インポート節に指定された各識別子について：
   - インポートされたモジュールにその名前の属性があるか確認する。
   - もし存在しなければ、その名前のサブモジュールをインポートし、再度インポートされたモジュールにその属性が存在するか確認する。
   - それでも属性が見つからなければ `ImportError` が発生する。
   - 属性が見つかれば、その値への参照が、`as` 節で別名が指定されていればその名前で、さもなければ元の属性名でローカル名前空間に保存される。

また、識別子のリストがアスタリスク（`*`）に置き換えられた場合は、モジュール内で定義された全ての公開名が、そのインポート文が現れるスコープのローカル名前空間にバインドされます。  
公開名は、モジュールの名前空間に `__all__` という変数が定義されているかどうかで決定されます。もし定義されていれば、`__all__` はそのモジュールで定義またはインポートされた名前の文字列のシーケンスでなければならず、その中の名前は全て公開と見なされます。  
`__all__` が定義されていなければ、アンダースコア（`_`）で始まらない全ての名前が公開名に含まれます。  
`__all__` には、モジュールの公開 API 全体が含まれるべきであり、意図せずに内部的な項目（ライブラリ内部で使用するインポート済みモジュールなど）がエクスポートされるのを防止するために用いられます。

ワイルドカード形式のインポート（`from module import *`）は、モジュールレベルでのみ許可され、クラスや関数定義内で使用すると `SyntaxError` が発生します。

モジュールを指定する際は、絶対パスを必ずしも記述する必要はなく、パッケージ内にモジュールが含まれている場合、同一トップパッケージ内で相対インポートを行うことができます。  
たとえば、`from . import mod` と記述すれば、モジュール `pkg.mod` がインポートされ、`from ..subpkg2 import mod` と記述すれば、`pkg.subpkg1` 内から `pkg.subpkg2.mod` がインポートされます。  
相対インポートの仕様については「パッケージ相対インポート」セクションを参照してください。

また、動的にインポートするモジュールを決定するために、`importlib.import_module()` が提供されています。

さらに、インポート時には `import` イベントが発生し、引数としてモジュール名、ファイル名、`sys.path`、`sys.meta_path`、`sys.path_hooks` が渡される場合があります。

---

## 7.11.1. **future** 文

**future** 文は、特定のモジュールが将来のリリースで標準となる構文または意味論でコンパイルされるべきであることを、コンパイラに指示するためのディレクティブです。

**future** 文は、互換性のない変更を導入する将来の Python バージョンへの移行を容易にすることを目的としています。これにより、機能が標準となる前に、モジュールごとに新機能を利用することが可能になります。

```
future_stmt ::= "from" "__future__" "import" feature ["as" identifier]
                ("," feature ["as" identifier])*
              | "from" "__future__" "import" "(" feature ["as" identifier]
                ("," feature ["as" identifier])* [","] ")"
feature     ::= identifier
```

**future** 文は、モジュールの先頭付近に記述されなければなりません。**future** 文の前に記述できるのは以下のものだけです：

- モジュールドキュメンテーション文字列（存在する場合）
- コメント
- 空行
- 他の **future** 文

**future** 文で必要な唯一の機能は、注釈です（PEP 563 を参照）。

Python 3 では、**future** により有効となった過去の機能も引き続き認識されます。たとえば、`absolute_import`、`division`、`generators`、`generator_stop`、`unicode_literals`、`print_function`、`nested_scopes`、`with_statement` などがあります。これらは常に有効であるため、後方互換性のために残されています。

**future** 文は、コンパイル時に特別に扱われ、コアな構文の意味論に変更をもたらすことがあります。場合によっては、新たな予約語が導入されるなど、互換性のない構文変更を伴うこともあり、その場合コンパイラはモジュールの解析方法を変更する必要があります。こうした決定は実行時まで先延ばしにすることはできません。

コンパイラは、特定のリリースに対して有効な機能名を把握しており、**future** 文内に不明な機能が含まれている場合はコンパイル時にエラーを発生させます。

実行時の意味論は通常の import 文と同じです：`__future__` という標準モジュールが存在し、通常の方法でインポートされます。

**future** 文としてではなく、単なる `import __future__ [as name]` は、特別な意味を持たず通常の import として扱われます。

また、`exec()` や `compile()` によってコンパイルされたコード内で **future** 文が存在する場合、デフォルトではその **future** 文に対応した新しい構文または意味論が適用されます。これについては、`compile()` 関数のドキュメントを参照してください。

対話型インタプリタ上で **future** 文を入力した場合、その効果はインタプリタセッションの残り全体に適用されます。もし `-i` オプション付きでスクリプトを実行し、そのスクリプト内に **future** 文が含まれている場合、スクリプト実行後に開始される対話型セッションにもその効果が及びます。

参照: PEP 236 - **future** への回帰  
（元々の **future** メカニズムの提案）

---

## 7.12. global 文

```
global_stmt ::= "global" identifier ("," identifier)*
```

`global` 文は、指定された識別子をグローバルとして解釈させます。`global` を用いずにグローバル変数に代入することは不可能ですが、自由変数はグローバルを宣言せずとも参照可能です。

`global` 文は、関数またはクラス本体全体に適用されます。もしグローバル宣言より前に変数が使用または代入されていれば `SyntaxError` が発生します。

※ 注意：`global` はパーサーへのディレクティブであり、同時にパースされたコードブロック全体にのみ適用されます。特に、`exec()` 関数に渡される文字列内のコードは、呼び出し元のコードブロックに影響を及ぼしません。`eval()` や `compile()` に渡されたコードも同様です。

---

## 7.13. nonlocal 文

```
nonlocal_stmt ::= "nonlocal" identifier ("," identifier)*
```

関数やクラスの定義が他の関数内にネストされている場合、その内部のスコープは外側の関数のローカルスコープとなります。`nonlocal` 文は、リストされた識別子を、既に外側のスコープで束縛されている名前として扱うよう指示します。これにより、カプセル化されたコードがその非ローカルな識別子を再束縛できるようになります。  
もし、同じ名前が複数の非ローカルスコープに束縛されている場合、最も内側の束縛が使用されます。  
もし、どの非ローカルスコープにもその名前が束縛されていない場合、または非ローカルスコープ自体が存在しない場合は、`SyntaxError` が発生します。

`nonlocal` 文は、関数またはクラス本体全体に適用され、宣言より前に変数が使用または代入されていれば `SyntaxError` となります。

参照: PEP 3104 - 外側スコープ内の名前へのアクセス

※ 注意：`nonlocal` もまたパーサーへのディレクティブであり、同時にパースされたコードブロックにのみ適用されます。

---

## 7.14. type 文

```
type_stmt ::= 'type' identifier [type_params] "=" expression
```

`type` 文は、型エイリアス（`typing.TypeAliasType` のインスタンス）を宣言します。

例えば、以下の文は型エイリアスを作成します：

```python
type Point = tuple[float, float]
```

このコードは、概ね次のようなコードと同等です：

```python
annotation-def VALUE_OF_Point():
    return tuple[float, float]
Point = typing.TypeAliasType("Point", VALUE_OF_Point())
```

※ ここでの `annotation-def` は注釈スコープを示しており、関数と似た動作をしますが、いくつかの細かな違いがあります。

型エイリアスの値は、注釈スコープ内で評価されます。型エイリアスが作成された時点では評価されず、型エイリアスの `__value__` 属性を通してアクセスされたときに初めて評価されます（遅延評価を参照）。これにより、型エイリアスがまだ定義されていない名前を参照することが可能となります。

型エイリアスは、名前の後に型パラメータリストを追加することでジェネリックにすることも可能です。詳細は「ジェネリック型エイリアス」を参照してください。

`type` はソフトキーワードです。

※ 3.12 で追加されました。

参照: PEP 695 - 型パラメータ構文  
（`type` 文およびジェネリッククラス・関数の構文が導入されました）

---

© Copyright 2001-2025, Python Software Foundation.  
このページは Python Software Foundation License Version 2 の下でライセンスされています。  
ドキュメント中の例やレシピ、その他のコードは Zero Clause BSD License の下で追加ライセンスされています。  
詳細は History and License を参照してください。

Python Software Foundation は非営利団体です。  
寄付をお願いします。

最終更新: 2025 年 2 月 28 日 (08:46 UTC)  
バグを発見しましたか？  
Sphinx 8.2.1 を使用して作成されています。

---

以上が、提供された Python ドキュメントの日本語訳となります。
